<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Uncatch â€” Velin Playground</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg:#0f0f12;
      --text:#f5f5f7;
      --radius:1rem;
      --shadow:0 30px 60px rgba(0,0,0,.5);
      --transition:.3s cubic-bezier(.4,.2,.2,1);
      --rainbow: linear-gradient(135deg,#a3150d 0%,#c75610 15%,#c4a423 30%,#80a317 45%,#1c6e0d 60%,#0e7d69 75%,#0e567d 85%,#183b73 90%,#331873 95%,#581873 98%,#a8439d 100%);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      overflow:hidden;
      height:100vh;
      display:flex;
      flex-direction:column;
    }
    .game-wrapper{
      position:relative;
      flex:1;
      display:flex;
      flex-direction:column;
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
      touch-action:none;
      cursor:none;
    }
    .scoreboard{
      position:fixed;
      top:12px;
      right:12px;
      background: rgba(255,255,255,0.04);
      padding:10px 16px;
      border-radius:8px;
      font-family: 'JetBrains Mono', monospace;
      font-weight:500;
      font-size:1rem;
      display:flex;
      gap:10px;
      align-items:center;
      backdrop-filter: blur(10px);
      z-index:10;
    }
    .score-label{
      letter-spacing:1px;
      text-transform: uppercase;
      font-size:.55rem;
      opacity:.8;
    }
    .score-value{
      font-size:1.35rem;
    }
    .hint{
      position:fixed;
      bottom:14px;
      left:50%;
      transform:translateX(-50%);
      background: rgba(255,255,255,0.03);
      padding:8px 14px;
      border-radius:999px;
      font-size:.75rem;
      display:flex;
      gap:6px;
      align-items:center;
      backdrop-filter: blur(8px);
      user-select:none;
      z-index:5;
    }
    .reset-btn{
      position:fixed;
      top:12px;
      left:12px;
      background: rgba(255,255,255,0.06);
      border:none;
      padding:8px 14px;
      border-radius:999px;
      cursor:pointer;
      color: var(--text);
      font-weight:600;
      font-size:.8rem;
      transition: var(--transition);
      backdrop-filter: blur(8px);
    }
    .reset-btn:hover{
      background: rgba(255,255,255,0.12);
    }
    .game-over {
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      background: rgba(15,15,18,0.9);
      backdrop-filter: blur(10px);
      z-index:20;
      padding:2rem;
      text-align:center;
      gap:1rem;
    }
    .game-over h1 {
      margin:0;
      font-size:2.5rem;
    }
    .game-over p {
      margin:0;
      font-size:1rem;
      opacity:.9;
    }
    .btn {
      background:#fff;
      color:#000;
      padding:.85rem 1.75rem;
      border:none;
      border-radius:1rem;
      cursor:pointer;
      font-weight:600;
      position:relative;
      overflow:hidden;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
    }
    .btn::before {
      content:"";
      position:absolute;
      inset:0;
      background: var(--rainbow);
      mix-blend-mode: overlay;
      opacity:.1;
      border-radius:inherit;
    }
    .small-fade {
      position:absolute;
      width:160px;
      height:160px;
      border-radius:50%;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      background: var(--rainbow);
      filter: blur(140px);
      opacity:.15;
      pointer-events:none;
    }
    @media (prefers-reduced-motion: reduce){
      * {animation:none !important; transition:none !important;}
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <canvas id="game"></canvas>
    <div class="small-fade" aria-hidden="true"></div>
    <div class="scoreboard" aria-label="score">
      <div>
        <div class="score-label">Score</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div style="margin-left:8px;display:flex;flex-direction:column;align-items:flex-start;">
        <div class="score-label">High</div>
        <div class="score-value" id="highscore">0</div>
      </div>
    </div>
    <button class="reset-btn" id="resetBtn">Restart</button>
    <div class="hint">Move with mouse or touch. Avoid the rainbow.</div>
    <div class="game-over" id="over" style="display:none;">
      <h1>You got caught</h1>
      <p>Your score: <span id="finalScore">0</span></p>
      <button class="btn" id="retry">Try Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    let W = canvas.width = window.innerWidth;
    let H = canvas.height = window.innerHeight;
    const scoreEl = document.getElementById("score");
    const highEl = document.getElementById("highscore");
    const overOverlay = document.getElementById("over");
    const finalScore = document.getElementById("finalScore");
    const resetBtn = document.getElementById("resetBtn");
    const retryBtn = document.getElementById("retry");

    let pointer = { x: W/2, y: H/2 };
    let player = { x: W/2, y: H/2, r: 12 };
    let chaser = { x: W/4, y: H/4, r: 18, speed: 0.8 };
    let orbs = [];
    let score = 0;
    let highscore = parseInt(localStorage.getItem("uncatch_high") || "0", 10);
    let lastTime = performance.now();
    let spawnTimer = 0;
    let difficultyTimer = 0;
    let gameOver = false;

    highEl.textContent = highscore;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);

    function distance(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

    function spawnOrb() {
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * Math.min(W,H)/3 + 60;
      const x = Math.max(25, Math.min(W-25, player.x + Math.cos(angle) * dist));
      const y = Math.max(25, Math.min(H-25, player.y + Math.sin(angle) * dist));
      orbs.push({ x, y, r: 8, collected: false, float: Math.random()*Math.PI*2 });
    }

    function update(dt) {
      if (gameOver) return;
      // pointer follow handled via events
      // player lerp to pointer for smoothing
      player.x += (pointer.x - player.x) * 0.3;
      player.y += (pointer.y - player.y) * 0.3;

      // chaser moves toward player
      const dirX = player.x - chaser.x;
      const dirY = player.y - chaser.y;
      const dist = Math.hypot(dirX, dirY);
      if (dist !== 0) {
        const normX = dirX / dist;
        const normY = dirY / dist;
        chaser.x += normX * chaser.speed * dt;
        chaser.y += normY * chaser.speed * dt;
      }

      // increase difficulty over time
      difficultyTimer += dt;
      if (difficultyTimer > 10000) {
        chaser.speed += 0.15;
        difficultyTimer = 0;
      }

      // spawn orbs periodically (max 6)
      spawnTimer += dt;
      if (spawnTimer > 1500 && orbs.length < 6) {
        spawnOrb();
        spawnTimer = 0;
      }

      // check orb collection
      orbs.forEach(o => {
        if (!o.collected && distance(player, o) < player.r + o.r) {
          o.collected = true;
          score += 1;
          scoreEl.textContent = score;
          if (score > highscore) {
            highscore = score;
            highEl.textContent = highscore;
            localStorage.setItem("uncatch_high", highscore);
          }
        }
      });
      // remove collected with small delay fade
      orbs = orbs.filter(o => !o.collected);

      // collision with chaser
      if (distance(player, chaser) < player.r + chaser.r) {
        endGame();
      }
    }

    function draw() {
      ctx.clearRect(0,0,W,H);

      // draw orbs
      orbs.forEach(o => {
        // floating effect
        const float = Math.sin(o.float + performance.now() * 0.002) * 2;
        o.float += 0.01;
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(o.x, o.y + float, o.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      });

      // draw player
      ctx.save();
      ctx.fillStyle = "#fff";
      ctx.shadowBlur = 14;
      ctx.shadowColor = "#fff";
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // draw chaser (rainbow glowing)
      const gradient = ctx.createRadialGradient(chaser.x, chaser.y, 0, chaser.x, chaser.y, chaser.r*2);
      gradient.addColorStop(0, "rgba(255,255,255,0.4)");
      gradient.addColorStop(0.3, "#a3150d");
      gradient.addColorStop(0.5, "#c75610");
      gradient.addColorStop(0.65, "#c4a423");
      gradient.addColorStop(0.8, "#0e567d");
      gradient.addColorStop(1, "rgba(168,67,157,0.25)");
      ctx.save();
      ctx.fillStyle = gradient;
      ctx.shadowBlur = 30;
      ctx.shadowColor = "#a8439d";
      ctx.beginPath();
      ctx.arc(chaser.x, chaser.y, chaser.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function loop(now) {
      const dt = Math.min(now - lastTime, 40);
      lastTime = now;
      update(dt / 16); // normalize roughly to 60fps scale
      draw();
      if (!gameOver) requestAnimationFrame(loop);
    }

    function endGame() {
      gameOver = true;
      finalScore.textContent = score;
      overOverlay.style.display = "flex";
    }

    function resetGame() {
      score = 0;
      scoreEl.textContent = score;
      chaser.x = Math.random() * W * 0.5 + W*0.25;
      chaser.y = Math.random() * H * 0.5 + H*0.25;
      chaser.speed = 0.8;
      orbs = [];
      difficultyTimer = 0;
      spawnTimer = 0;
      gameOver = false;
      overOverlay.style.display = "none";
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    // input handling
    function setPointer(x,y){
      pointer.x = Math.max(0, Math.min(W, x));
      pointer.y = Math.max(0, Math.min(H, y));
    }
    window.addEventListener("mousemove", e => {
      setPointer(e.clientX, e.clientY);
    });
    window.addEventListener("touchmove", e => {
      if (e.touches[0]) {
        setPointer(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, {passive:false});
    window.addEventListener("touchstart", e => {
      if (e.touches[0]) {
        setPointer(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, {passive:false});

    resetBtn.addEventListener("click", resetGame);
    retryBtn.addEventListener("click", resetGame);

    // start
    resetGame();
  </script>
</body>
</html>
